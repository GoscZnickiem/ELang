Fuck.

========================================================

fun main() -> int {
	return 42;
}

========================================================

fun f(int a, int b) -> int {
	int x = a + b;
	int y = a * b;
	return x + y;
}

fun main() -> int {
	int r = f(4, 6)
	return r - 2;
}

========================================================

type Vec = struct {
	float x;
	float y;
};

fun main() -> int {
	Vec v;
	v.x = 1;
	v.y = 1;
	Vec u = {1, 2};
	u.x += v.x;
	u.y += v.y;
	return u.x * 10 + u.y;
}

========================================================

type T = int; // kind value declaration

fun main() -> int {
	T x = 15;
	return x + 16;
}

=======================================================

fun main() -> int {
	return 5 operator _ @ _ [](int a, int b) { return a * b + 1; } 7;
}   // returns 36

========================================================

fun main() -> int {
	return true operator _ @ _ @ _ [](bool p, int a, int b) { if(p) return a; else return b; } 23 @ 42;
}   // returns 23

// fucking three-way anonymous operator bruh

========================================================

functor Optional<type T> -> type:
	class {
		T value;
		bool exists;
	public:
		T& get() {
			if (exists)
				return value;
			throw error("value doesn't exist")
		};
	};

functor = <implicit type T> -> (Optional<T>&, T&) -> T&:
	operator _ @ _ [](Optional<T>& opt, T& arg) -> T& {
		return opt.value = arg;
	};

functor = <implicit type T> -> (T&, Optional<T>&) -> T&:
	operator _ @ _ [](T& arg, Optional<T>& opt) -> T& {
		return arg = opt.get();
	};

functor * <implicit type T> -> (Optional<T>&) -> T&:
	operator _ * [](Optional<T>& opt) -> T& {
		return opt.get();
	}

fun main() -> int {
	Optional<int> i = 5; 
	return *i;
}

========================================================

functor Add<int a, int b> -> int = a + b; // it is in fact useless but why wouldn't this work?

fun main() -> int {
	return Add<12, 30>;
}

========================================================

functor Adder<int a> ->
	fun(int b) -> int = {
		return a + b;
	}
// also useless but still why not. Also the notation is fucked but I didn't think about anonymous functions (lambdas)

fun add2(int) -> int = Adder<2>;

fun main() -> int {
	return add2(3) + Adder<8>(15);
}

========================================================

// https://betterttv.com/emotes/662e62934e3d1ff63d186407
functor Adder<type T> -> functor<T a> -> fun(T b) -> T =
	functor<T a> -> fun(T b) -> T = 
		fun(T b) -> T = {
			return a + b;
		}
// this is unacceptable. The format: functor name<arguments> -> return kind = ... doesn't work with anonymous functor construction: functor<arguments> -> return kind = ...
// Also I don't know if functor should be a kind. Seems useful but also cursed and hard af to implement. After all functions CAN'T return functions.
// Then again it would be useful because otherwise how do we do functor<type T, T value>? We kinda can't or it would be atrocious.

========================================================

// I could infer the return kind tho...
functor Adder<type T> -> 
	functor<T a> -> 
		fun(T b) -> T { // could also type infer the return type of anonymous functions
			return a + b;
		}
// That is a bit more acceptable ig. Allows for lukier syntaktyczny:
functor Adder<type T, T a> ->
	fun<T a> -> T {
		return a + b;
	}
// The compiler could very easily interpret this as if it was written like the above version
